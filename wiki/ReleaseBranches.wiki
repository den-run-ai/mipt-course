#summary Как можно работать с ветками (branches) кода

= Предисловие =
На данной странице примеры будут приводиться в виде команд SVN.
Предполагается, что структура папок выглядит примерно так:
{{{
Корень
 |-- trunk
 |- branches
 |    |-- branch_1
 |    |-- branch_2
 |    |-- branch_3
 |
 |- releases
      |-- 1.0
      |-- 1.1
      ...
      |-- 1.23
}}}

Вообще, работать с branch'ами в SVN менее удобно, чем в git, но на данной странице разобран пусть и более сложный и неудобный, но более распространённый инструмент.
Для пользователя git работа с ветками является гораздо более частым действием, поэтому предполагается что опытный пользователь сможет без труда применить в git аналоги нижеприведённых команд SVN.

Основные приводимые ниже идеи (что хранить в какой ветке, когда-что-куда переносить и т.д.) не зависят от используемой системы контроля версий.

= Подход "стабильный trunk" =
В `trunk` хранится только стабильный код - тщательно оттестированный, прошедший все возможные review и т.п.<br>

Для изменений кода: добавления новой функциональности, исправления ошибок - другими словами, решения задач, разработчики (или команды разработчиков) создают для каждой такой задачи отдельную ветку:
{{{
$ svn copy URL/trunk URL/branches/feature_X -m "Create a branch for a new feature X"
Committed revision BRANCH_POINT.
}}}
Вся работа над задачей теперь ведётся в папке `branches/new_feature`.
Для экономии дискового пространства разработчик (или команда) может вместо создания нового клиента переключить свои текущие клиенты на работу с веткой:
{{{
$ svn switch URL/branches/feature_X
}}}

Если во время решения задачи в `trunk` попал некоторый код, который хотелось бы использовать (например, другая команда исправила ошибку), то код в ветке можно обновить до новой версии `trunk`:
{{{
# Выполнять из папки, синхронизованной с feature_X
$ svn merge -r BRANCH_POINT:HEAD URL/trunk
$ svn commit -m "Take the fresh trunk with a fix for bug 42"  # желательно указать ревизию trunk
}}}

Когда задача решена, ветка проходит review и объединяется с `trunk`:
{{{
$ svn switch URL/trunk
$ svn merge -r BRANCH_POINT:HEAD URL/branches/feature_X
$ svn commit -m "Add new feature X"
}}}
(В принципе, провежуточные результаты работы можно вливать в `trunk` таким же образом)

Теперь ветку можно удалить:
{{{
$ svn rm URL/branches/feature_X -m "The branch is no longer needed"
}}}

Общая схема выглядит примерно так:
{{{
trunk
 |
 X  # svn copy creates revision BRANCH_POINT
 |->feature_X
 |   |
 |   |
 |-->X  # update the branch to trunk via svn merge
 |   |
 |   |
 |-->X  # update the branch to trunk via svn merge
 |   |
 |   /
 X<==   # merge the branch to trunk and remove it
 |
 |
}}}

*TODO*: _обязательно ли запоминать BRANCH_POINT?_

Для выпуска очередной версии продукта пользователям достаточно взять текущую версию `trunk` и скомпилировать инсталлятор.
При этом удобно сделать копию `trunk` в подпапку `releases`, чтобы потом можно было легко посмотреть код выпущенного релиза:
{{{
$ svn copy URL/trunk URL/releases/1.23 -m "Tagging release 1.23. Let's go get some beer?"
}}}

= Подход "разработка ведётся в trunk" =
Если в команде используется [https://code.google.com/p/mipt-course/wiki/CodeReview code review перед коммитом], а также применяется [https://code.google.com/p/mipt-course/wiki/BuildbotSetup регулярное тестирование], то может оказаться более удобным вести работу прямо в `trunk`.

Для подготовки к новому релизу можно, например, периодически создавать новую ветку и присваивать ей некоторый порядковый номер: `branches/123`.

Далее, ветка отдаётся на QA (Quality Assurance - проверка качества): security review, focus group review, beta testers и т.д.
Если в коде, оказавшемся в ветке `123`, обнаруживаются ошибки, то они исправляются и в `trunk`, и в ветке:
{{{
# Делается в trunk
$ svn commit -m "Fix bug 42"
...
Commited revision 666.

# Делается в ветке branches/123
$ svn merge -c 666 URL/trunk
}}}

В тот момент, когда делается очередной релиз из ветки `123`, создаётся новая ветка в папке `releases`, например `releases/1.0.123.0`.<br>
Если в этом релизе находят какие-нибудь ошибки, то после их исправления в ветке `123` можно сделать новый релиз `releases/1.0.123.1`.

Такой подход позволяет поддерживать сразу несколько актуальных релизов, как делают, например:
  * Microsoft Windows
  * Ubuntu (LTS версия 10.04, свежая версия 11.04)
  * Chromium (dev, beta, stable версии)

= Послесловие =
Два вышеописанных подхода можно совместить (например, вести основную работу в trunk, но некоторые экспериментальные наработки вести в отдельных ветках).

В принципе, ветки в SVN являются лишь папками. Поэтому, конкретные варианты наименований и расположений веток и релизов в каждом проекте может быть своё. По этой же причине существует ряд других подходов в ведению веток и релизов.

Для пользователей `git` - можно почитать пример системы веток и конкретные команды работы с ними здесь: http://habrahabr.ru/blogs/Git/106912/
#summary Как можно работать с ветками (branches) кода

= Предисловие =
На данной странице примеры будут приводиться в виде команд SVN.

Вообще, работать с branch'ами в SVN менее удобно, чем в git, но на данной странице разобран пусть и более сложный и неудобный, но более распространённый инструмент.
Для пользователя git работа с ветками является гораздо более частым действием, поэтому предполагается что опытный пользователь сможет без труда применить в git аналоги нижеприведённых команд SVN.

Основные приводимые ниже идеи (что хранить в какой ветке, когда-что-куда переносить и т.д.) не зависят от используемой системы контроля версий.

Предполагается, что структура папок в репозитории выглядит примерно так:
{{{
Корень
 |- /trunk
 |- /branches
 |    |-- /branch_1
 |    |-- /branch_2
 |    |-- /branch_3
 |
 |- /releases
      |-- /1.0
      |-- /1.1
      ...
      |-- /1.23
}}}

= Подход "стабильный trunk" =
В `trunk` хранится только стабильный код - тщательно оттестированный, прошедший все возможные review и т.п.<br>

Для изменений кода: добавления новой функциональности, исправления ошибок - другими словами, решения задач, разработчики (или команды разработчиков) создают для каждой такой задачи отдельную ветку:
{{{
$ svn copy URL/trunk URL/branches/feature_X -m "Create a branch for a new feature X"
Committed revision BRANCH_POINT.
}}}
Запоминаем номер ревизии `BRANCH_POINT` для ветки `feature_X` - например, можно записать её в файл `branches/feature_X/BRANCHED_AT`.

Вся работа над задачей теперь ведётся в папке `branches/new_feature`.
Для экономии дискового пространства разработчик (или команда) может вместо создания нового клиента переключить свои текущие клиенты на работу с веткой:
{{{
$ svn switch URL/branches/feature_X
}}}

Если во время решения задачи в `trunk` попал некоторый код, который хотелось бы использовать (например, другая команда исправила ошибку), то код в ветке можно обновить до новой версии `trunk`:
{{{
# Выполнять из папки, синхронизованной с feature_X
$ svn merge URL/trunk
$ svn commit -m "Take the fresh trunk with a fix for bug 42"  # желательно указать ревизию trunk
Commited revision SYNCED_TO.
}}}
После этого заменяем запомненное значение `BRANCH_POINT` на значение `SYNCED_TO` (например, записываем в файл `BRANCHED_AT`), чтобы избежать лишних _merge conflict_.

*TODO*: можно ли делать проще? Если не пользоваться `-r BRANCH_POINT:HEAD`, то при финальном `merge` может возникнуть куча merge conflicts.

Когда задача решена, ветка проходит review и объединяется с `trunk`:
{{{
$ svn switch URL/trunk
$ svn merge -r BRANCH_POINT:HEAD URL/branches/feature_X
$ svn commit -m "Add new feature X"
}}}
(В принципе, провежуточные результаты работы можно вливать в `trunk` таким же образом)

Теперь ветку можно удалить:
{{{
$ svn rm URL/branches/feature_X -m "The branch is no longer needed"
}}}

Общая схема выглядит примерно так:
{{{
trunk
 |
 X  # svn copy creates revision BRANCH_POINT
 |-> feature_X
 |    |
 |    |
 |--->X  # update the branch to trunk via svn merge
 |    |
 |    |
 |--->X  # update the branch to trunk via svn merge
 |    |
 |    /
 X<===   # merge the branch to trunk and remove it
 |
...
}}}

Для выпуска очередной версии продукта пользователям, разработчику достаточно взять текущую версию `trunk` и скомпилировать инсталлятор.
При этом удобно сделать копию `trunk` в подпапку `releases`, чтобы потом можно было легко посматривать код этого релиза:
{{{
$ svn copy URL/trunk URL/releases/1.23 -m "Tagging release 1.23. Let's go get some beer?"
}}}

= Подход "разработка ведётся в trunk" =
Если в команде используется [https://code.google.com/p/mipt-course/wiki/CodeReview code review перед коммитом], а также применяется [https://code.google.com/p/mipt-course/wiki/BuildbotSetup регулярное тестирование], то может оказаться более удобным вести работу прямо в `trunk`.

Для подготовки к новому релизу можно, например, периодически создавать новую ветку и присваивать ей некоторый порядковый номер: `branches/123`.

Далее, ветка отдаётся на QA (_quality assurance_ - проверка качества): security review, focus group review, beta testers и т.д.

Если в ходе QA ветки `123` обнаруживаются ошибки, то они исправляются и в ветке, и в `trunk`:
{{{
# Делается в ветке branches/123
$ svn commit -m "Fix bug 42"
...
Commited revision 666.

# Делается в trunk, если код ещё не претерпел серьёзных изменений
$ svn merge -c 666 URL/branches/123
}}}

В тот момент, когда делается очередной релиз из ветки `123`, создаётся новая ветка в папке `releases`, например `releases/2.0.123.0`.<br>
Если в этом релизе находят какие-нибудь ошибки, то после их исправления в ветке `123` можно сделать новый релиз `releases/2.0.123.1`.
{{{
trunk
 |
 X
 |-> 123 # send to QA
 |    |
 |--->X  # merge bugfixes after QA
 |    |  # send to QA again
 |    |
 |    X  # QA approved to publish a beta version
 |    |-> 2.0.123.0 (beta)
 |    |
 |--->X  # merge fixes for bugs found in beta
 |    |
 |    X  # publish a stable version
 |    |-> 2.0.123.1 (stable)
 |    |
...  ...
}}}
Ветка `123` продолжает существовать, пока не потеряет актуальность.

Такой подход позволяет поддерживать сразу несколько актуальных релизов, как делают, например:
  * Microsoft Windows (одновременно существуют 
  * Ubuntu (LTS версия 10.04, свежая версия 11.04)
  * Chromium (dev, beta, stable версии)

= Послесловие =
Два вышеописанных подхода можно совместить (например, вести основную работу в trunk, но некоторые экспериментальные наработки вести в отдельных ветках).

В принципе, ветки в SVN являются лишь папками. Поэтому, конкретные варианты наименований и расположений веток и релизов в каждом проекте может быть своё. По этой же причине существует ряд других подходов в ведению веток и релизов.<br>
(Напишите мне известный Вам интересный вариант?)

Для пользователей `git` - можно почитать пример системы веток и конкретные команды работы с ними здесь: http://habrahabr.ru/blogs/Git/106912/
#summary Информация для моих студентов-второкурсников.

<font color=red>Данная страничка НЕ относится к техкурсу.</font><br>Просто в силу разных причин мне сейчас удобнее размещать информацию для второкурсников здесь..

= Цели 3го семестра =
Научиться:
  * Читать документацию (в т.ч. на английском)
  * Корректно обрабатывать ошибки
  * Контролировать ресурсы, не допуская утечек (free, delete, fclose, ...)
  * Базовым представлениям о компьютерных сетях
  * Передавать данные между разными компьютерами
  * Параллельно/распределённо решать задачи с очевидным внутренним параллелизмом

= Задача bruteforce =
В файле `seminars/unsorted/md5sum.cpp` хранится функция
{{{
void md5sum(const string &str, string *result);
}}}
вычисляющая [http://en.wikipedia.org/wiki/Md5 MD5 hash] строки `str`.

== Подзадача №0 ==
Используя функцию `md5sum`, напишите функцию
{{{
bool bruteforce_md5(const string &hash, const string &alphabet, int max_len, string *result);
}}}
которая перебирает все пароли длины от `0` до `max_len` из алфавита
`alphabet` и если находит пароль с MD5-хэшем равным `hash`,
то возвращает true и записывает найденный пароль в `*result`.<br>
Если не находит - возвращает `false`.<br>
(Если надо, можете вместо "`const string &`" использовать "`const char *`", как вам удобнее)

_Такой метод взлома паролей называется [http://en.wikipedia.org/wiki/Brute-force_attack Brute-force]._

Для тестирования можете воспользоваться командами:
{{{
$ echo -n hello | md5sum
# Печатает MD5-хэш слова "hello":
5d41402abc4b2a76b9719d911017c592
}}}
и аналогично для других слов.

Чтобы вы представляли порядок времён, подбор пароля "hello" по алфавиту "a-z" на одном ядре занимает примерно 15-20 секунд.

*Совет:* постарайтесь структурировать код так, чтобы потом было легче параллелить вычисления по схеме "divide and conquer" или "map-reduce".

== Подзадача №1 ==
Сделать подбор пароля в два процесса - один считывает с консоли параметры подбора (целевой hash, алфавит, максимальную длину), затем отдаёт данные другому процессу. Второй процесс выполняет подбор и сообщает о результатах первому процессу, который выводит их на консоль.

В этой и в последующей подзадаче необходимо сделать две реализации: через named pipe и через сокеты.<br>
Настоятельно рекомендуется, чтобы использовались классы и полиморфизм со следующим интерфейсом для абстракции канала передачи:
{{{
class Connection {
 public:
  virtual ~Connection() {}

  virtual bool SendString(const std::string &str) = 0;

  // Если кто-то не знает, что такое enum или как ими пользоваться - напишите мне, я расскажу на семинаре.
  enum Status {
    CLOSED,
    OK, 
    ERROR,
  };

  virtual Status ReceiveString(std::string *result) = 0;
};
}}}
или аналогичным.

Требуется, чтобы в коде, отвечающем за подбор пароля, не было никаких pipe-специфичных или socket-специфичных строк кода.

Отличия в реализациях допускаются только в классах-наследниках `Connection`, а также в коде, ответственном за установление соединения (тут у named pipe'ов и сокетов не так много общего, полиморфизм только мешает).<br>
Например, допускается различный `main()` - параметры соединения имеет смысл указывать в виде аргументов командной строки.

*Совет:* сделайте общую часть в файле `bruteforce.cpp`, pipe-специфичный код и соответствующий `main()` в файле `pipe_connection.cpp`, сокет-специфичный код и соответствующий `main()` в файле `socket_connection.cpp`.<br>
Тогда собирать код можно будет так:
{{{
g++ bruteforce.cpp pipe_connection.cpp -lcrypto -o pipe_bruteforce
}}}
для pipe-версии и
{{{
g++ bruteforce.cpp socket_connection.cpp -lcrypto -o socket_bruteforce
}}}
для сокет-версии.

Убедиться, что реализация через сокеты работает по сети!

== Подзадача №2 ==
То же, что и №1, но процессы должны поделить работу пополам, а вычисления должны идти параллельно (должно стать примерно вдвое быстрее).<br>Считать, что скорость вычислений у двух процессов примерно равна.

Убедиться, что реализация через сокеты работает по сети!

== Подзадача №3 ("на 10") ==
Сделать то же, что и сокет-версию №1, но на этот раз к одному серверу ("ведущему" компьютеру) должны подключаться `N` других компьютеров для параллельного подбора (должно быть примерно в N раз быстрее чем подбор в одиночку).<br>В идеале, данная реализация должна достаточно хорошо работать даже в случае если эти `N` компьютеров демонстрируют различную скорость вычислений.

Данное решение предполагает использование функций `select` (будет рассказана на семинаре) или `poll`/`epoll` и/или неблокирующихся сокетов.<br>
В обоих случаях потребуется немного дополнить/изменить интерфейс `Connection`, эти изменения нужно будет самостоятельно придумать и аргументировать.

Гранд-проверка - запуск подбора пароля на 16 компьютерах в учебной аудитории!

= Задача "нет, я хочу мыть посуду из задавальника" =
Если вы хотите решать задачу из задавальника - ок (_ну что ж вы так!_), тогда рекомендуемый интерфейс:
{{{
class IpcInterface {
 public:
  static IpcInterface *Create();  // Имеет разную реализацию в зав-ти от того, какой .cpp файл вы вкомпилируете.
  virtual ~IpcInterface() {}

  virtual bool Close() = 0;

  virtual bool StartProducer() = 0;
  virtual bool StartConsumer() = 0;

  virtual bool SendMessage(const string &message) = 0;

  enum Status {
    CLOSED,
    OK, 
    ERROR,
  };
  virtual Status ReadMessage(string* message) = 0;
};
}}}
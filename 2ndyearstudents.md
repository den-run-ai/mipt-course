<font color='red'>Данная страничка НЕ относится к техкурсу.</font><br>Просто в силу разных причин мне сейчас удобнее размещать информацию для второкурсников здесь..<br>
<br>
<h1>Цели 4го семестра</h1>
Каждый студент должен:<br>
<ul><li>Разобраться в ООП и основных паттернах;<br>
</li><li>Разобраться в общих чертах как работают:<br>
<ul><li>Десктопные приложения<br>
</li><li>Игры<br>
</li><li>Вычислительные эксперименты (математика, физика, экономика)<br>
</li><li>(?) Web-приложения<br>
</li><li>(?) Мобильные приложения<br>
</li><li>(?) Вычисления на GPU<br>
</li><li><место для вашего варианта><br>
</li></ul></li><li>В команде 2-4 человек написать проект одного из вышеперечисленных типов.</li></ul>

Формальные требования к проекту доступны на <a href='https://sites.google.com/site/miptcscourses/seminars/4-fupm-frtk'>сайте кафедры</a>

В рамках каждого проекта нужно будет:<br>
<ul><li>Самостоятельно разобраться в одной библиотеке/API;<br>
</li><li>У каждого студента должна быть своя часть кода, в которой он хорошо разбирается;<br>
</li><li>Также, каждый участник проекта должен иметь представление об остальных частях проекта.<br>Для этого рекомендуется писать легкочитаемый код с <a href='http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml'>хорошим Code Style</a>, а также тесты.</li></ul>

<hr />
<h1>Цели 3го семестра</h1>
Научиться:<br>
<ul><li>Читать документацию (в т.ч. на английском)<br>
</li><li>Корректно обрабатывать ошибки<br>
</li><li>Контролировать ресурсы, не допуская утечек (<code>free</code>, <code>delete</code>, <code>fclose</code>, ...)<br>
</li><li>... и при этом без дубликации кода.<br>
</li><li>Пользоваться <code>strace</code>, <code>valgrind</code> и Google для решения возникающих проблем<br>
А также:<br>
</li><li>Передавать данные между процессами на одном компьютере<br>
</li><li>Базовым представлениям о компьютерных сетях<br>
</li><li>Передавать данные между процессорами на разных компьютерах<br>
</li><li>Параллельно/распределённо решать задачи с очевидным внутренним параллелизмом</li></ul>

<h1>Задача bruteforce</h1>
В файле <code>seminars/unsorted/md5sum.cpp</code> хранится функция<br>
<pre><code>void md5sum(const string &amp;str, string *result);<br>
</code></pre>
вычисляющая <a href='http://en.wikipedia.org/wiki/Md5'>MD5 hash</a> строки <code>str</code>.<br>
<br>
<h2>Подзадача №0</h2>
Используя функцию <code>md5sum</code>, напишите функцию<br>
<pre><code>bool bruteforce_md5(const string &amp;hash, const string &amp;alphabet, int max_len, string *result);<br>
</code></pre>
которая перебирает все пароли длины от <code>0</code> до <code>max_len</code> из алфавита<br>
<code>alphabet</code> и если находит пароль с MD5-хэшем равным <code>hash</code>,<br>
то возвращает true и записывает найденный пароль в <code>*result</code>.<br>
Если не находит - возвращает <code>false</code>.<br>
(Если надо, можете вместо "<code>const string &amp;</code>" использовать "<code>const char *</code>", как вам удобнее)<br>
<br>
<i>Такой метод взлома паролей называется <a href='http://en.wikipedia.org/wiki/Brute-force_attack'>Brute-force</a>.</i>

Для тестирования можете воспользоваться командами:<br>
<pre><code>$ echo -n hello | md5sum<br>
# Печатает MD5-хэш слова "hello":<br>
5d41402abc4b2a76b9719d911017c592<br>
</code></pre>
и аналогично для других слов.<br>
<br>
Чтобы вы представляли порядок времён, подбор пароля "hello" по алфавиту "a-z" на одном ядре занимает примерно 15-20 секунд.<br>
<br>
<b>Совет:</b> постарайтесь структурировать код так, чтобы потом было легче параллелить вычисления по схеме "divide and conquer" или "map-reduce".<br>
<br>
<h2>Подзадача №1</h2>
Сделать подбор пароля в два процесса - один считывает с консоли параметры подбора (целевой hash, алфавит, максимальную длину), затем отдаёт данные другому процессу. Второй процесс выполняет подбор и сообщает о результатах первому процессу, который выводит их на консоль.<br>
<br>
<b>ПРИМЕЧАНИЕ: Если Вы способны сразу сделать подзадачу №2 - подзадачу №1 можно не делать!</b>

В этой и в последующей подзадаче необходимо сделать две реализации: через named pipe и через сокеты.<br>
Настоятельно рекомендуется, чтобы использовались классы и полиморфизм со следующим интерфейсом для абстракции канала передачи:<br>
<pre><code>class Connection {<br>
 public:<br>
  virtual ~Connection() {}<br>
<br>
  virtual bool SendString(const std::string &amp;str) = 0;<br>
<br>
  // Если кто-то не знает, что такое enum или как ими пользоваться - напишите мне, я расскажу на семинаре.<br>
  enum Status {<br>
    CLOSED,<br>
    OK, <br>
    ERROR,<br>
  };<br>
<br>
  virtual Status ReceiveString(std::string *result) = 0;<br>
};<br>
</code></pre>
или аналогичным.<br>
<br>
Проверьте, что реализация через сокеты работает по сети!<br>
<br>
<h3>О организации и дубликации кода в этой и последующих подзадачах</h3>
Мне совсем неинтересно проверять один и тот же код, раскопированный по шести разным файлам.<br>Вам самим будет неинтересно копировать исправления между 5 копиями.<br>А если вы забудете скопировать очередное исправление в очередную копию - сами будете потом отлаживаться ;)<br>
<br>
<b>В свете этого,</b>

Требуется, чтобы в коде, отвечающем за подбор пароля (на сервере и клиенте), не было никаких pipe-специфичных или socket-специфичных строк кода. Рекомендуется эти части выделить в самостоятельные функции, принимающие на вход <code>Connection*</code>.<br>
В частности, это подразумевает что в реализации через named pipe'ы нужно организовать дуплексную связь (двухстороннюю) - двумя pipe'ами.<br>
<br>
Отличия в реализациях для pipe и для socket'ов допускаются только в классах-наследниках <code>Connection</code>, а также в коде, ответственном за установление соединения (тут у named pipe'ов и сокетов не так много общего, полиморфизм только мешает).<br>
Например, допускается различный <code>main()</code> - т.к. параметры соединения<br>
имеет смысл указывать в виде аргументов командной строки, а у <code>pipe</code>'ов и<br>
сокетов адресные пространства сильно отличаются.<br>
<br>
<b>Совет:</b> сделайте общую часть в файле <code>bruteforce.cpp</code>, pipe-специфичный код и соответствующий <code>main()</code> в файле <code>pipe_connection.cpp</code>, сокет-специфичный код и соответствующий <code>main()</code> в файле <code>socket_connection.cpp</code>.<br>
Тогда собирать код можно будет так:<br>
<pre><code>g++ bruteforce.cpp pipe_connection.cpp -lcrypto -o pipe_bruteforce<br>
</code></pre>
для pipe-версии и<br>
<pre><code>g++ bruteforce.cpp socket_connection.cpp -lcrypto -o socket_bruteforce<br>
</code></pre>
для сокет-версии.<br>
<br>
<h2>Подзадача №2</h2>
То же, что и №1, но процессы должны поделить работу пополам, а вычисления должны идти параллельно (должно стать примерно вдвое быстрее).<br>Можно считать, что скорость вычислений у двух процессов примерно равна.<br>
<br>
Проверьте, что реализация через сокеты работает по сети!<br>
<br>
<h2>Подзадача №3 ("на 10")</h2>
Сделать то же, что и сокет-версию подзадачи №2, но на этот раз к одному серверу ("ведущему" компьютеру) должны подключаться <code>N</code> других компьютеров для параллельного подбора (должно быть примерно в N раз быстрее чем подбор в одиночку).<br>В идеале, данная реализация должна достаточно хорошо работать даже в случае если эти <code>N</code> компьютеров демонстрируют различную скорость вычислений.<br>
<br>
Данное решение предполагает использование функций <code>select</code> (будет рассказана на семинаре) или <code>poll</code>/<code>epoll</code> и/или неблокирующихся сокетов.<br>
В обоих случаях потребуется немного дополнить/изменить интерфейс <code>Connection</code>, эти изменения нужно будет самостоятельно придумать и аргументировать.<br>
<br>
Гранд-проверка - запуск подбора пароля на 16 компьютерах в учебной аудитории!<br>
<br>
<h1>Задача "нет, я хочу мыть посуду из задавальника"</h1>
Если вы хотите решать задачу на передачу данных "из задавальника" - ок (<i>ну что ж вы так!</i>), тогда рекомендуемый интерфейс:<br>
<pre><code>class IpcInterface {<br>
 public:<br>
  static IpcInterface *Create();  // Имеет разную реализацию в зав-ти от того, какой .cpp файл вы вкомпилируете.<br>
  virtual ~IpcInterface() {}<br>
<br>
  virtual bool Close() = 0;<br>
<br>
  virtual bool StartProducer() = 0;<br>
  virtual bool StartConsumer() = 0;<br>
<br>
  virtual bool SendMessage(const string &amp;message) = 0;<br>
<br>
  enum Status {<br>
    CLOSED,<br>
    OK, <br>
    ERROR,<br>
  };<br>
  virtual Status ReadMessage(string* message) = 0;<br>
};<br>
</code></pre>